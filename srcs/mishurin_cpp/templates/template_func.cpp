#include <iostream>
#include <vector>

// Template functions overloading
/*
 * (1)
 Перегрузка функций, при выборе какую функцию задействовать,
 компилятор выберет более частный случай реализации функции
 Если существует шаблонная функция f, которая принимает тип Т и функция f принимающая тип int.
 Если мы вызывем функцию f и передадим аргументов значение типа int - f(42), компилятор выберет
 частную функцию void f(int x).

 Две евристики перегрузки функцииЖ
 1. Частная лучше общего - Если есть две версии которые одинаково хорошо подходят, но при этом одна более частная, чем другая
 	выбери ее.
 2. Если есть версия шаблонная в которой ты можешь получить точное соответствие подставив некоторое T,
 	а есть версия более частная, но чтобы ее вызвать тебе нужно приведение типов, то предпочти версию, где тебе
 	не нужно делать приведение типов.(Точное соответсвие лучше приведения типов.


 */
//(1)
//template < typename T >
//
//void f(T x) {
//	(void)x;
//	std::cout << 1 << std::endl;
//}
//
//void f(int x) {
//	(void)x;
//	std::cout << 2 << std::endl;
//}
// (2)
template < typename T, typename U>
void	f(const T &x, const U &y) {
	(void) x;
	(void) y;
	std::cout << "1" << std::endl;
}

template < typename T >

void	f(const T &x, const T &y) {
	(void) x;
	(void) y;
	std::cout << "2" << std::endl;
}

void	f(int x, double y) {
	(void) x;
	(void) y;
	std::cout << "3" << std::endl;
}


int main() {
	//
	f(0.0, 0);
}